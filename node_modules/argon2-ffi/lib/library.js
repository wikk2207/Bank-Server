'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.argon2dVerify = exports.argon2iVerify = exports.argon2dHashRaw = exports.argon2dHashEncoded = exports.argon2iHashRaw = exports.argon2iHashEncoded = exports.argon2Encodedlen = exports.argon2ErrorMessage = undefined;

var _ffiNapi = require('ffi-napi');

var _ffiNapi2 = _interopRequireDefault(_ffiNapi);

var _refNapi = require('ref-napi');

var _refNapi2 = _interopRequireDefault(_refNapi);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var RELEASE_DIR = _path2.default.join(__dirname, '..', 'build', 'Release');
var LIBRARY_SEARCH_PATHS = [_path2.default.join(RELEASE_DIR, 'argon2'), _path2.default.join(RELEASE_DIR, 'obj.target', 'argon2')];

function getLibraryPath() {
  var expectedExtensions = ['so', 'dylib', 'dll'];

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = LIBRARY_SEARCH_PATHS[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var searchPath = _step.value;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = expectedExtensions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var extension = _step2.value;

          var libraryPath = searchPath + '.' + extension;
          if (_fs2.default.existsSync(libraryPath) && _fs2.default.lstatSync(libraryPath).isFile()) {
            return libraryPath;
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  throw new Error('Could not find argon2 library');
}

var lib = new _ffiNapi2.default.Library(getLibraryPath(), {
  argon2i_hash_encoded: ['int', ['uint32', 'uint32', 'uint32', // t_cost, m_cost, p
  _refNapi2.default.refType('void'), 'size_t', // password
  _refNapi2.default.refType('void'), 'size_t', // salt
  'size_t', // hash length
  _refNapi2.default.refType('char'), 'size_t']], // encoded hash

  argon2i_hash_raw: ['int', ['uint32', 'uint32', 'uint32', // t_cost, m_cost, p
  _refNapi2.default.refType('void'), 'size_t', // password
  _refNapi2.default.refType('void'), 'size_t', // salt
  _refNapi2.default.refType('void'), 'size_t']], // hash output

  argon2d_hash_encoded: ['int', ['uint32', 'uint32', 'uint32', // t_cost, m_cost, p
  _refNapi2.default.refType('void'), 'size_t', // password
  _refNapi2.default.refType('void'), 'size_t', // salt
  'size_t', // hash length
  _refNapi2.default.refType('char'), 'size_t']], // encoded hash

  argon2d_hash_raw: ['int', ['uint32', 'uint32', 'uint32', // t_cost, m_cost, p
  _refNapi2.default.refType('void'), 'size_t', // password
  _refNapi2.default.refType('void'), 'size_t', // salt
  _refNapi2.default.refType('void'), 'size_t']], // hash output

  argon2i_verify: ['int', [_refNapi2.default.refType('char'), // encoded
  _refNapi2.default.refType('void'), // password
  'size_t']], // password length

  argon2d_verify: ['int', [_refNapi2.default.refType('char'), // encoded
  _refNapi2.default.refType('void'), // password
  'size_t']], // password length

  argon2_encodedlen: ['size_t', ['uint32', 'uint32', 'uint32', // t_cost, m_cost, p
  'uint32', 'uint32']], // salt length, hash length

  argon2_error_message: ['string', ['int']] // error_code
});

var argon2ErrorMessage = lib.argon2_error_message,
    argon2Encodedlen = lib.argon2_encodedlen,
    argon2iHashEncoded = lib.argon2i_hash_encoded,
    argon2iHashRaw = lib.argon2i_hash_raw,
    argon2dHashEncoded = lib.argon2d_hash_encoded,
    argon2dHashRaw = lib.argon2d_hash_raw,
    argon2iVerify = lib.argon2i_verify,
    argon2dVerify = lib.argon2d_verify;
exports.argon2ErrorMessage = argon2ErrorMessage;
exports.argon2Encodedlen = argon2Encodedlen;
exports.argon2iHashEncoded = argon2iHashEncoded;
exports.argon2iHashRaw = argon2iHashRaw;
exports.argon2dHashEncoded = argon2dHashEncoded;
exports.argon2dHashRaw = argon2dHashRaw;
exports.argon2iVerify = argon2iVerify;
exports.argon2dVerify = argon2dVerify;